Reactjs v18.2.0 강좌정리

1. 개요

  - facebook에서 제공하는 Front-end 프레임워크. ( JS 기반 )
    예> React.js, Vue.js , Angular(구글)


2. React 종류

  1) React.js (*)
     - 수업에서 배우는 내용
     - CSR( Client Side Rendering : 클라이언트인 웹브라우저에서 화면을 만들고 랜더링함. )

  2) Next.js
     - SSR ( Server Side Rendering: JSP처럼 서버에서 화면을 만들고 만든 화면을 클라이언트에게 전송해서 랜더링함 )

  3) React Native
     - 모바일용 어플리케이션 개발시 사용. ( 모바일용 React )

3. 환경설정
 
   1) node 설치

     http://nodejs.org
      
   2) VSC 설치 
    
      https://code.visualstudio.com/

   3) VSC 플러그인

     - live Server
     - Auto Rename Tag
     - Auto Close Tag
     - Reactjs Snippets ( 함수기반 컴포넌트 개발용 )

   4) 크롬에서 React 플러그인 설치


4. React 프로젝트 생성

    https://ko.legacy.reactjs.org/docs/create-a-new-react-app.html#createreact-app ( 18.2.0 해당 )
    https://ko.react.dev/ ( v19 )

   1) 문법

       npx create-react-app  프로젝트명

     가. 설치

	npm install npm -g  <== npm 최신버전 설치

        npx create-react-app my-app	

     나. 버전 변경

        - package.json 에서 다음과 같이 변경한다.

	 "react": "^19.0.0",        ==> "react": "^18.2.0"
         "react-dom": "^19.0.0",    ==> "react-dom": "^18.2.0"

	- 수정후 다시 다운로드 받기
	  cd my-app
	  npm install   <== package.json의 변경사항을 반영.
 
     다. 성능측정 코드 삭제

         src/index.js 에서 다음 코드 삭제하기

	 5라인의 import reportWebVitals from './reportWebVitals'; 삭제
	 17라인의 reportWebVitals(); 삭제

   
     라. 실행
        
	cd my-app
	npm start

	
	http://localhost:3000/ 요청되어 화면이 랜더링됨.

#############################################################################################

  5.  my-app 프로젝트 구조

      node_modules  :   maven의 의존성 저장 디렉터리인 .m2 역할
                       필요시 제거하고 나중에 npm install 명령어로 다시 다운로드가 가능함.

      public        :  웹브라우저인 클라이언트에서 접근이 가능
                      예>  http://localhost:3000/robots.txt

                       개발에 필요한 image는 public 에 저장하지 않음.
		    : index.html 파일이 메인 홈페이지 파일 ( 수정할 필요 없음)
		      실제 랜더링할 화면을 보여주는 template 역할담당.
      

      src           : private 특징 (   웹브라우저인 클라이언트에서 접근이 불가 )
		    : index.js 파일이 시작점 역할. ( 수정할 필요 없음)
		      <App /> 를 index.html의 id="root" 에 랜더링 함. 

		    : App.js 는 React 컴포넌트로서 함수형 컴포넌트로 작성되어 있음. 
		      반드시 첫글자는 대문자로 지정 필수.
		      이유는 <컴포넌트명 /> 형식으로 사용되어야 하기 때문에 일반 html과 구분 목적 )
		      예> <App />
		      이 파일에서 실제 화면을 구축하면 됨.

     package.json   : maven 의 pom.xml 역할
                      nodejs의 모듈 관리 설정 파일임.

		      예> npm install axios  실행하면 package.json에 "axios": "^1.7.9" 추가됨
		         npm uninstall axios 실행하면 제거됨.

    README.md       : 실행 명령어 가이드
                 
		    예> 실행 : npm start
		       배포  : npm run build


  6. Reactjs에 실행가능한 컴포넌트 작성 방법

    1) 클래스형 기반
      - 거의 사용 안함.
      - 초창기에는 클래스형 기반으로 개발함.
        이유는 클래스형에서 사용가능하나 함수형에서는 사용 못하는 기능들이 많았음.
	나중에 함수형에서도 사용가능하도록 기능을 추가했음.(hook 이라고 함. useXXX )

    2) 함수형 기반 (***********)

      가. 함수 선언 ( 반드시 첫글자는 대문자로 지정, 일반적인 html태그와 구별하기 위함. )

         // 함수선언식 ( 이름있는 함수)
         function Home(){   <=== 화면 전체 또는 화면의 일부분이 된다. MVC 에서 View 담당하는 역할임.

	 }
	 // 함수 표현식 ( 이름없는 함수, 익명함수)
         const Home = function (){

	 };

	 // arrow 
         const Home = ()=>{

	 };

      나. 함수안에서 화면을 구성(JSX)하고 return 해야 된다.

	 function Home(){

	    return (  <== () 생략가능한 경우는 JSX 한줄인 경우에 가능함.

		 JSX 문법 ( html 비슷)
	    );
	 }
       
      다. 외부에서 사용하기 위해서 export|export default 한다.

         export {Home}
	 export default Home

    
      라. CSS 스타일 지정은 컴포넌트당 하나씩 작성한다.
        
	 예> Home.js, Home.css  만들고 import './Home.css'; 사용함.
	    Menu.js, Menu.css  만들고 import './Menu.css'; 사용함.

     마. 사용할 때는 import 하고 <컴포넌트 /> 형식으로 사용함.
        예> <Home />
	   <Menu />


7. JSX

   1) 개요
     - JSX ( JavaScript XML)로서 Reactjs에서 UI구현시 사용됨.
     - JSX는 랜더링 되기 전에 작동 가능한 JS로 바뀐다. ( babel 도구, https://babeljs.io/ )
       결국은 JSX는 웹브라우저에서 실제 사용 불가능.

   2)문법
    
     - 함수형 컴포넌트에서 return ( JSX ) 표현식 이용.
       ()는 생략가능한데 JSX 한줄인 경우에 가능하다.
       예>  return <div className="bottom">bottom 화면입니다.</div>

   3)특징
     가.반드시 단 하나의 root 태그가 존재해야 된다. ( XML 문법 )
     나.일반 html태그에서는 종료태그가 없는 태그가 존재가능( 예> <hr> , <br> , <img> )
       하지만 JSP에서는 반드시 종료태그가 존재해야 됨.  ( 예> <hr></hr>, <br></br> )

     다. 함수형컴포넌트에서의 변수값을 JSX 에서 출력할 수 있다.
        문법: {변수값}  // JSP의 <%= 변수값 %> 동일한 기능
     
     라. {변수값} 에서 산술연산, 비교연산자, 논리 연산자, 3항연산자 등 모둑 가능
      
        예>  { age > 10 }
	    { age + 10 }
	    { age > 10 ? 값:값2 }
	    { age > 10 && age < 20 }

       단, 논리값(true/false), null, undefiend 는 {변수값} 사용시 출력안됨.
          출력할려면 {조건식?"true":"false"}
	          {조건식?"null":null}
    

     마. JSX에서 CSS 적용하는 방법 2가지

        a. className 속성
	   - 일반적인 html에서는 class 속성을 이용해서 스타일을 지정한다.
	     JSX에서는 class 값이 키워드이기 때문에 사용하지 못하고 대신 className 속성을 사용해야 된다.


	b. style 속성

           - 일반적인 html에서도 지원되는 속성.
	     JSX에서는 중첩 {{css속성명:속성값}} 사용해야된다.
	     예>
	        var xxx ={color:red}

		<p style={xxx} >
		<p style={{color:red}} >

            - 일반적인 html의 CSS 는 케밥표기법( 예> font-size:40px )사용하는데
	      JSX 의 CSS 는 카멜표기법 ( 예> fontSize: 40px ) 사용한다.
	      예> <p style={{color:'red', fontSize: '40px' }} >

    바. 조건부 랜더링 (******************)

      - 조건을 지정해서 true 인 경우에만 화면에 랜더링하자.
       문법: { true  && <보여줄컴포넌트> }

    
    사. spread 연산자

      문법: {...변수}

      예>
         원본코드:
         <img src="a.jpg" width="100" height="100" >
	 
	 spread 적용코드:
	 const attr ={src:"a.jpg", width:"100", height:"100">

	 JSX: <img {...attr} >

    아. JSX에서 이벤트처리시 이벤트 핸들러 속성은 반드시 카멜표기법을 사용해야된다.
        ( onClick, onChange, onSubmit, ... )

       예>
          기존 html 이벤트 처리: <button onclick="콜백함수">ok</button>

	  JSX 이벤트 처리: <button onClick="콜백함수">ok</button>

    자. JSX 주석

     문법: {/*  JSX   */}

    차. JSX에서 {json객체} 출력불가

 ////////////////////////////////////////////////////////////////////////////////////

  8. image 사용하기
 
    - public 폴더가 아닌 src 폴더에 저장하자.

      예> src/assets 에 이미지를 저장


    - 사용할때는 import 해서 사용한다. ( 권장 )

       예>
         import daum from './assets/daum.png'

	 <img src={daum} width="100" height="100" />


    - 이유는 public에 저장하면 npm run build 할때 누락이 자주 되기 때문이다.

  ==> 화면 레이아웃은 계층적인 구조로 만든다. ( JSP의 include 기능과 비슷 )
/////////////////////////////////////////////////////////////////

 9. props 
https://ko.reactjs.org/docs/components-and-props.html

   1) 개요
     - 계층적인 구조에서 부모컴포넌트에서 자식컴포넌트로 데이터를 전달하는 방법.  

   2) 특징
      - 단방향 ( 부모에서 자식으로만 전달 가능, 자식에서 부모로 데이터 전달은 불가능.)
      - 전달되는 데이터는 모든 데이터 가능 ( 논리값, 문자(열),숫자,함수,배열,json,... )
        전달하는 방법은 문자열 제외하고 {값} 형식을 사용해야된다.

   3) 구현방법1- 자식컴포넌트의 속성이용

      가. 부모 코드
	
	 문법: <자식컴포넌트  속성명=속성값  속성명=속성값 />

      나. 자식 코드
       
        - 자식코드에서는 함수 컴포넌트의 파라미터인 props로 부모에서 전달하는 데이터를 참조할 수 있다.
	  props 변수에는 {속성명:속성값, 속성명:속성값} 형식으로 전달됨
         function 자식컴포넌트(props){
		
		props.속성명 으로 참조
	 }


        - 자식코드에서는 함수 컴포넌트의 파라미터에서 직접 객체분해할당에서 데이터를 참조할 수 있다.

	  function 자식컴포넌트({속성명, 속성명}){}

    

    3) 구현방법2- 자식컴포넌트의 body 이용

        가. 부모 코드

            문법: <자식컴포넌트>
                    자식에게전달할데이터  <== 일반데이터값 또는 JSX 가능
	         </자식컴포넌트>


	 나. 자식 코드

	     - 자식코드에서는 함수 컴포넌트의 파라미터인 props로 부모에서 전달하는 데이터를 참조할 수 있다.
		 props 변수에는 {children:전달값} 형식으로 전달됨 

                 function 자식컴포넌트(props){
		 
		     props.children 참조
		 }

    3) 구현방법3 - 속성과 body 혼합

         가. 부모 코드
		
	      문법: <자식컴포넌트  속성명=속성값  속성명=속성값>
                    자식에게전달할데이터  <== 일반데이터값 또는 JSX 가능
	           </자식컴포넌트>
  

         나. 자식 코드

	   -자식코드에서는 함수 컴포넌트의 파라미터인 props로 부모에서 전달하는 데이터를 참조할 수 있다.
		 props 변수에는 {children:전달값, 속성명:속성값} 형식으로 전달됨 

                 function 자식컴포넌트(props){
		 
		     props.children 참조
		     props.속성명     참조
		 }

   ====> 계층구조가 많아지면 최상위 부모에서 최하위 자식에게 데이터를 전달하기 위한 방법이 복잡해질 수 있음.( props drilling 문제)
//////////////////////////////////////////////////////////////////////////////////////////////

10.  배열 데이터를 JSX에서 반복해서 출력하기.

  - JSX에서는 {json객체} 출력 불가
  - 반복처리시 개별적인 JSX태그를 구별하기 위한 unique 값을 설정해야 됨.
    key="unique값"
    이유는 React는 화면랜더링할 때 매번 똑같은 화면을 랜더링하지 않고
    수정된 항목만 랜더링한다. 이때 비교하기 위한 unique한 값이 필요함.

    예>
        // 반복할 배열 (원래는 서버에서 가져온 데이터임)
		const userList = [{username:"홍길동1",age:20},
		  {username:"홍길동2",age:30},
		  {username:"홍길동3",age:40}
		];

       
      {userList.map((ele,idx)=>{
        return <div key={idx}> {ele.username}, {ele.age}</div>
      })}

 //////////////////////////////////////////////////////////////////////////

11.  이벤트 처리
 
   https://ko.reactjs.org/docs/handling-events.html

   1) 이벤트 처리 함수는 컴포넌트 안에서 정의한다.

     예>
         function App(){  // 컴포넌트

	    //이벤트 함수
	    function handleEvent(){}
	    var handleEvent=function(){}
	    var handleEvent=()=>{}

	 }

   2) 이벤트 핸들러는 반드시 카멜표기법을 사용해야 된다.

     예> <button onClick=이벤트함수>

   
   3) 이벤트 함수 형식 2가지

    가. 콜백함수 형식 ( 함수명만 지정하는 방식임 )

     예> <button onClick={handleEvent}>

       - 임의의 파라미터값을 전달 불가
       - 자동으로 이벤트 객체가 전달됨.

	예>  
	    function handleEvent(e){
	      console.log("handleEvent", e)
	    }

	     <h2>1. 콜백 형식</h2>
             <button onClick={handleEvent}>OK1</button>

    나. arrow 함수 작성하고 직접 이벤트함수 호출 형식


     예> <button onClick={()=>handleEvent(}>

      - 임의의 파라미터값을 전달 가능
      - 자동으로 이벤트 객체가 전달안되기 때문에
        명시적으로 전달해야 된다.

     예>

        function handleEvent2(e, n){
         console.log("handleEvent2", e, n)
        }

	 <button onClick={(e)=>handleEvent2(e, 100)}>OK3</button>

/////////////////////////////////////////////////////////////////////////////
