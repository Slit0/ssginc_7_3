 Spring Framework 및 SpringBoot3


 1. Spring Framework

  1) 개요

   - Road Johnson 이 'Export One-on-One J2EE Development without EJB(Enterprise Java Beans)' 책을 통해서 소개. 
   - 2003년 2월부터 오픈 소스로 시작된 프로젝트.

  2) 특징
   - 경량의 컴포넌트.
   - IoC ( Inversion of Control: 제어의 역행) 컨테이너(스프링의 특정 클래스) 기반에서 관리됨.
     ( Serlvet/JSP가 tomcat 컨테이너에서 관리된것과 유사 )
     IoC 개념? 클래스를 직접 생성하지 않고 의존성도 직접 설정하지 않음. 모두 Spring에게 맡김.

   - JDBC 추상화 ( Mybatis 처럼 wrap한 클래스들 제공 ==> 예외처리 불필요 ... )
   - 선언적 트랜잭션 ( 어노테이션으로 트랜잭션 처리 가능 ==> @Transactional 지정. 모두 성공하면 자동으로 commit,
                                               만약 하나라도 실패하면 모두 자동으로 rollback 됨.
      예>
          @Transactional
          public int delAndUpdate(){

              session.delete(~~~~);
	      session.update(~~~~);

	  }
   - 다양한 뷰(html화면) 기술 ( JSP, Thymeleaf, velocity 등 )
   - 검증된 Spring MVC 아키텍쳐 제공.
   - REST API 지원. ( 클라이언트와 서버간에 JSON 데이터 포맷으로 통신하는 방법의미)

      예>  클라이언트                         서버(웹서버)
          ---------                      ------
	  PC용 웹브라우저       JSON
	  모바일,테블릿   <---------------->
	  OTT 셋탑박스
	  자동차,,,
	  ..

                     
  3) Spring Framework 생태계
     
     https://spring.io

     - Spring Framework
     - Spring Boot
     - Spring Security
     - Spring Data
     - Spring AI
       ...

  4) Spring Framework 버전

    https://spring.io/projects/spring-framework#learn

    - 6.X ( 2022년 )
      JDK 17+

  5) 용어 정리
   
   가. POJO ( Plain Old Java Object)
     - 일반적인 오래된 자바 객체라는 의미.
     - 어떠한 클래스 또는 인터페이스를 상속 및 구현하지 않아서
       어떤 개발환경에서도 사용가능한 특징을 가짐.
         예>

        
	HttpServlet
	    |
	    |
	 MyServlet ( MyServlet 는 웹어플리케이션 환경에서만 사용 가능한 제약이 됨 )

   나. Java Beans
      - EJB 에서 사용했던 용어
      - 특정한 규칙을 가짐
        a. public 기본 생성자만 존재
	b. getter/setter 메서드 존재
	c. implments Serialzable

   다. Spring bean
      - POJO 기반의 Spring 어플리케이션에서 만든 모든 자바 클래스 의미.

  
   라. IoC ( Inversion of Control : 제어의 역행 )
      - 우리가 필요한 빈(클래스)를 직접 생성하거나 빈간에 의존성을 직접 설정하지 않고
        우리대신에 외부(IoC Container)에서 필요한 빈을 생성 및 의존성을 설정하는 개념.

                   
   마. IoC Container

      - IoC 방법으로 빈(클래스)를 관리한다는 의미에서 IoC Container 라고 부름.
        (Spring Container, Spring Context 모두 동일한 개념이다. )

      - 하드웨어 개념이 들어갔으나  일반 클래스이다.  ( XXXApplicationContext )


      * 계층 구조


 BeanFactory(인터페이스) MessageSource(인터페이스)
	        |
                |
	    ApplicationContext ( 인터페이스, org.springframework.context )

	         |
		 |
            AnnotationConfigApplicationContext(클래스, Java SE 환경의 IoC Container 임)
	    GenericXmlApplicationContext(클래스, Java SE 환경의 IoC Container 임)
	    ..

	    XXXWebApplicationContext(클래스, Java EE 환경의 IoC Container 임)

  

   바. 의존성 주입 ( Dependency Injection: DI )
  
      - 개념: 임의의 클래스에서 다른 클래스를 참조할 때
            직접 생성하는 것이 아니고 외부에서 생성한후 생성자 또는 setter 메서드 이용해서 
	    설정하는 방법 의미함.

      - 종류 2가지

        a. 생성자 주입 ( Constructor-based Dependency Injection )
	b. setter 메서드 주입 ( setter-based Dependency Injection )

     예>

         BoardListServlet     BoardService                              BoardDAO
	                       
			        BoardDAO dao;
			       public void setDao(BoardDAO dao){
			         this.dao =dao;
			       }

			       public BoardService(BoardDAO dao){
			         this.dao =dao;
			       }
	
	BoardService service =
	   new BoardServiceImpl(new BoardDAO());  // 생성자 주입
	//service.setDao(new BoardDAO());         //  setter 메서드 주입


2. 환경 설정

  1) JDK 17 설치
  2) SpringBoot 3.2.8 ( Spring Framework 6.X 내장됨 )
    => SpringBoot 3 버전은 JDK 17+ 필요함.
  
  3) 개발툴 설치
    - STS ( Spring Tool Suite ) 툴 지원.
    - 현재 지원되는 종류 2가지

      sts3 : Spring Framework 와 Spring Boot를 각각 개발할 수 있는 개발툴.


      sts4 : Spring Boot 만 지원되는 개발툴.
     

    - 한글 인코딩 확인
       
        window > preference > general > workspace 에서 UTF-8 확인

    - JSP/CSS/jS 위한 web 플러그인 추가

       hep > eclipse marketplace >  web 검색 > Eclipse Enterprise Java and  Web Developer Tool 3.36 설치

  
  4) tomcat 설치 안함.
     이유는 SpringBoot에서는 내장 tomcat 을 사용한다.


 3.  SpringBoot 프로젝트 작성

   1) 로컬로 프로젝트 작성

     STS > File > NEW > Spring Starter Project (Boot 용 프로젝트 )

   2) 웹사이트 이용 ( initializer 방법 )

    http://start.spring.io 

    project: maven 선택




 4. 빌드툴(build tool)

   - 개발할 때 도움을 받을 수 있는 툴.

   - 전통적인 프로그램 개발 프로세스 ( 수동으로 설정 )


   소스작성--->필요한jar다운로드 및 컴파일 ---> 단위테스트 ---> 패키징(jar, war) -----> 배포

    
                    
           <----------------------------------------------------------->
	     자동화 가능

    - 종류 2가지

     1) maven
       - 설정정보를 pom.xml 파일에 설정
       - 빌드 과정 단계
         a. validate
	 b. compile
	 c. test
	 d. package
	 e. install ( 패키징 )  clean (퍄키징 삭제)
	 f. deploy

     
     2) gradle
       - 설정정보를 build.gradle 파일에 설정


    - 필요한 의존성을 설정하는 방법
      
      http://mvnrepository.com 에서 필요한 키워드 입력하고  maven 또는 gradle 항목에서 복사해서 사용함.


5.  maven 빌드툴의 기본 디렉터리 구조

     src/main/java
      ==> *.java 가 저장
      ==> 패키지 지정

     src/main/resources
     ==> *.java 제외한 나머지 파일들
       ( 예> jdbc.properties, Configuration.xml, Mapper.xml 등 )

     src/test/java
      ==> 단위테스트용 *.java 저장

     src/test/resources
      ==> 단위테스트용 *.java가 필요한 파일들


     JRE System library ( JDK 17 라이브러리 )
     Maven Dependency
     ==> pom.xml에 등록된 의존성 파일들(*.jar)이 저장
     ==> 기본 저장 디렉터리는 C:\Users\ssginc73\.m2\repository 이다.
         가끔식 네트워크 이슈로 다운로드가 안 될수 있음.
	 해결은 강사 및 같은 조원들에게 요청 ( repository.zip )

     pom.xml ( Project Object Model )
      - 전반적인 설정정보 저장.
       예> 버전, 의존성파일(dependency),....
      - 계층구조로 되어있음 ( 부모에 해당되는 pom.xml 이 존재함 )


6.  Application 파일

  - src/main/java 에 저장되어 있고 반드시 필요한 코드임. ( 웹 어플리케이션을 개발할때도 필요함 )
  - 프로그램 시작점(starting point) 역할.

	@SpringBootApplication
	public class Application {

		public static void main(String[] args) {
			SpringApplication.run(DemoApplication.class, args);
			
		}

	}
  - SpringBoot 웹 어플리케이션 개발시 배포는 jar로도 가능하다. 이유는  main 메서드를 가지고 있기 때문이다.
    (일반적으로 비웹은 jar로 배포하고 웹은 war로 배포함)

  
  - @SpringBootApplication 의 3가지 기능
  https://docs.spring.io/spring-boot/reference/using/using-the-springbootapplication-annotation.html


     a. @EnableAutoConfiguration : pom.xml에 <dependency>태그로 등록된 라이브러리를 보고, 그에 알맞은 최적의 설정정보를 자동으로 설정해줌.
                                  예> spring-boot-starter-web 지정하면 자동으로 웹어프리케이션 개발 위한 설정들이 자동으로 셋팅됨.
     b. @ComponentScan : 자동으로 빈(클래스)를 찾아서 new 해줌.
                         단, Application.java 가 가진 패키지의 서브패키지로 만들어야 됨.
     c. @SpringBootConfiguration : 자동으로 추가되는 설정 이외의 개발자가 필요시 추가적인 Configuration 설정이 가능함.


7. Spring Boot의 추가적인 설정 정보 방법

    src/main/resource/application.properties 에 설정

    예> DB연동시 필요시 4가지 정보,
       tomcat의 port 번호,
       ...
       ..

#########################################################################################################

8. 로깅 (logging) 처리

  1)개념
   - 어플리케이션을 개발할 때 문제가 발생되면 대부분 콘솔(console) 정보를 보고 문제를 해결.
     콘솔에 출력되는 정보를 로그(log) 라고 부름.

   - 필요시 로그 출력은 이전에는 System.out.println으로 해결했으나 앞으로는 전문적인 로그 관리 라이브러리를 사용해야 된다.

   - 대표적인 로그 관리 라이브러리
     a. log4j ( 구현체 )
     b. logback (구현체, Spring Boot 기본 로그임 )

   - SLF4j 
    ==> 인터페이스로서 Log4j와 Logback 구현체들이 SLF4j 인터페이스를 implments해서 만들어짐.
        따라서 실제로 SLFj4 사용하면 Log4j에서 logback으로 변경시 코드를 수정할 필요가 없다.

  - 로그 레벨 5가지

      trace
      debug
      info (기본)
      warn
      error

   동작방식은 지정된 레벨 및 하위까지 포함해서 로그가 출력됨.

  - 구현 방법

    가. Logger 생성
  
       // Logging의 인터페이스 기능인 slf4j 사용.
       import org.slf4j.Logger;
       import org.slf4j.LoggerFactory;

       Logger logger = LoggerFactory.getLogger(클래스명.class);	 

    나. 로그레벨에 해당되는 메서드 호출

       logger.trace(값);
       logger.debug(값);
       logger.info(값); // 기본
       logger.warn(값);
       logger.error(값);

    다. application.propeties에서 로그레벨 변경
     
       문법:  logging.level.패키지=로그레벨

       logging.level.root=warn  # 전체 패키지 로그 설정
       #logging.level.org.springframework=info  # org.springframework 패키지믄 info로 커스터마이징
	logging.level.com.exam=warn             # com.exam 패키지믄 warn 로 커스터마이징

	logging.file.name=c:\\Temp\\app.log     # 파일로 로그 저장.

#########################################################################

9. 빈 ( 클래스) 생성

  - 직접 new 하지 않음.
  - 권장하는 방법은 권장패키지 구조를 이용하는 것이다.
   https://docs.spring.io/spring-boot/reference/using/structuring-your-code.html

  - 자동생성 빈 생성 방법- 2 step

    step1: 권장패키지 구조로 만듬.
           @SpringBootApplication 가진 Application.java의 패키지의 서브 패키지로 만듬.

    step2: 자동으로 생성할 빈을 어노테이션으로 지정해야됨.
           - @Component  <== 범용적으로 사용
	   - @Service    <== ServiceImpl 역할
	   - @Repository <== DAO 역할
	   - @Controller <== 서블릿 역할
	   - @Configuration <== 설정 정보를 추가할 때 ( application.properties 대신에 ) 


10. 의존성 주입 1 ( dependency injection : DI )
 
   1) 개념
     특정 A클래스에서 다른 B 클래스를 참조할 때 A클래스에서 B의 참조변수가 필요하다.
     이때 B 클래스를 외부에서 생성해서 A 클래스에게 전달할 수 있다.

     예>
        A ----------------> B
      
      B b;


   2) 방법 2가지

    가. 생성자 이용 (권장)

     예>
			  DeptService
	Application <---> DeptServiceImpl  <------------------> DeptDAO
	  main()
                                           <------------------> UserDAO

                         public DeptServiceImpl(DeptDAO dao,UserDAO dao2){}

                  
    나. @Autowired 어노테이션 이용

     		          DeptService
	Application <---> DeptServiceImpl  <------------------> DeptDAO
	  main()                           
	                                    <------------------> UserDAO
                          @Autowired 
                          DeptDAO deptDAO;

			  @Autowired 
                          UserDAO userDAO;



11. 빈 접근하는 방법.

   @SpringBootApplication
public class Application implements CommandLineRunner{

	@Autowired
	ApplicationContext ctx; // AnnotationConfigApplicationContext 의존성주입됨
	
	//1. Logger 얻기
	private Logger logger = LoggerFactory.getLogger(getClass());
	
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);		
	}

	@Override
	public void run(String... args) throws Exception {
		logger.info("Application: {} ", ctx);
		
		// 빈참조
		DeptServiceImpl service = ctx.getBean("xxx", DeptServiceImpl.class);
		List<String> list = service.list();
		logger.info("List: {} ", list);
		
	}


12. 의존성 주입 2 ( dependency injection : DI )

   1)개념
   기본적으로 생성자 주입 또는 @Autowired는  동일한 타입을 주입을 시킴.
   따라서 동일한 타입이 한개면 그것이 주입되고 
   만약에 동일한 타입이 여러개면 어떤 클래스를 주입할지 모르기 때문에 에러가 발생됨.
   따라서 명시적으로 주입할 클래스를 알려줘야 된다. 이때 @Qualifier("빈이름") 사용한다.

  예>
			  DeptService                            CommonDAO (인터페이스)
	Application <---> DeptServiceImpl  <------------------>  DeptDAO
	  main()                                                 UserDAO

	                  @Autowired
			  @Qualifier("dept")
			   CommonDAO dao;
	
			   또는
	
			  CommonDAO dao;

			  public DeptServiceImpl(@Qualifier("빈이름")  CommonDAO dao){
			   this.dao = dao;
			  }

13.  빈의 scope
https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#page-title

   1) 개념
      ApplicationContext에서 생성된 빈(클래스)는 싱글톤(singleton)으로 관리된다.
      즉 단 한번만 생성됨. 
      따라서 bean을 요청하면 항상 동일한 인스턴스(100번지)를 반환하게 된다.

   2) scope 값 종류

     singleton : 기본, 단 한번만 생성됨. 따라서 bean을 요청하면 항상 동일한 인스턴스(100번지)를 반환하게 된다.
                 여러 사용자가 공유가 가능 ( thread-unsafe )
     
     prototype : bean을 요청하면 매번 새롭게 생성해서 반환.
                 여러 사용자가 공유 불가 ( thread-safe)

     request : web 환경,  HttpServletRequest scope와 동일

     session : web 환경,  HttpSession scope와 동일

     application : web 환경,  ServletContext scope와 동일

   
   3) scope 값 변경
https://docs.spring.io/spring-boot/docs/3.2.12/reference/pdf/spring-boot-reference.pdf

     - @Scope 이용

     - 문법:

        @Scope(value=ConfigurableBeanFactory.SCOPE_SINGLETON) <== @Scope("singleton")
	@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE) <== @Scope("prototype")
	..

   
14. 빈의 초기화 작업 및 cleanup 작업

   - 서블릿의 lifecycle과 비슷한 개념 ( 예> init()과 destroy() )
   - 구현
     
      @PostConstruct
      public void start(){
         //초기화
      }	
	
      @PreDestroy
      public void shutdown(){
        // cleanup
      
      }	

 
15. profile

 1) 개념
  - 개발할 때 다양한 환경을 구축해서 개발함

  예> dev 환경(개발환경), Q/A 환경,  prod 환경(배포환경)


    //개발환경

    Application <---------> DeptServiceImpl <---------> H2DAO  <----> H2, Redis (경량 DB)


     //배포환경

    Application <---------> DeptServiceImpl <---------> MySQLDAO  <----> MySQL, Oracle( enterprise DB)

  
 2) 구현방법 1 -  프로파일에 따른 properties 선택하는 방법

   각 환경에 맞는 application.properties 작성하자.

    - application.properties ( 기본 )
      ==> spring.profiles.active=prod

    - 문법: application-프로파일명.properties
     예> application-dev.properties
         ==> H2 연동설정 정보

        application-prod.properties
	==> MySQL 연동설정 정보

 2) 구현방법 2 -  프로파일에 따른 빈 선택하는 방법


   예>     
	@Repository
	@Profile("prod")
	public class MySQLDAO {



	@Repository
	@Profile("dev")
	public class H2DAO {



16. AOP ( Aspect Oriented Programming : 관점 지향 프로그래밍 )

  1) 개념

   // 현재코드
                            
   웹브라우저 <---------------> Servlet <---------> Service <-------------> DAO <--------> mysql
                           - 핵심코드              - 핵심코드                - 핵심코드
			   - 부수코드(로깅)          - 부수코드(로깅)            - 부수코드(로깅)
 
	
	핵심코드: 로그인, 회원가입, 장바구니, ......

	부수코드: 예외처리, 로깅, 보안, 트랜잭션처리,....

 
    결론은 혼합(핵심+부수)된 코드를 핵심코드와 부수코드를 분리해서  부수코드가 필요한 레이어에서 주입받아서 사용하도록 하자.


     웹브라우저 <---------------> Servlet <---------> Service <-------------> DAO <--------> mysql
                           - 핵심코드              - 핵심코드                - 핵심코드
			   

			     부수코드구현클래스
			      -부수코드(로깅)

  2) AOP 기술

    가. AspectJ
      - AOP 원천기술 ( 1995년 )
      - 다양한 주입시점이 있음
      예> 핵심코드를 가진 Servlet의 특정 메서드 호출할 때,
         핵심코드를 가진 Servlet의 변수값이 변경될 때,
         핵심코드를 가진 Servlet이 객체생성 될 때,
	 ...



    나. Spring AOP
      - 원천기술인 AspectJ에서 일부분만 빌려서 사용함.
        따라서 pom.xml에 <dependency> 필요.
      - 단 하나의 주입시점만 가짐. ( 핵심코드를 가진 Servlet의 특정 메서드 호출(************)할 때)


 3) 용어정리

   가. aspect : 부가기능 구현 클래스
   나. joinpoint :  target object 와 aspect가 만나는 시점 의미.
                   원천기술인 AspectJ는 다양한 시점이 있으나 Spring AOP에서는 메서드 호출 시점이다.
   다. pointcut  :  target object 의 어떤 메서드를 호출했을 때 join할 지 표현식을 의미함. 예> list()

   라. advice    : target object 의 
                  메서드 호출전 ( before advice )
		  메서드 호출후 ( after advice ) 
		  메서드 호출해서 성공시 ( after returning advice )
                  메서드 호출해서 에러발생시 ( after throwing advice ) 
	          메서드 호출전,호출후,성공시,에러발생시 모두 포함하는 경우 ( around advice)
   마. weaving   : 조인(주입) 의미
   바. target object : 핵심 클래스 의미



     // 핵심클래스                                         // 부가기능 구현 클래스

    public class DeptServiceImpl{                      public class LogPrintAspect{
							 
							  public void print(){
							     logger.info(...);
							  }
        // 핵심기능: 목록보기
        public List<String> list(){                     }
           ....
	    
	}

	public int insert(){                     }
           ....
	    
	}

    }

  4) 실습
   
   가.  의존성 설정
	<!-- AOP 설정-->
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	<!-- AOP 설정-->


   나. target object ( 핵심기능 클래스 )


   다. aspect ( 부가기능 클래스 )